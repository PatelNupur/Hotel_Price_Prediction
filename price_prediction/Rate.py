# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zcb2ci1YBgkOKTBjv_tXiWBwKgE1FFVF
"""

# Commented out IPython magic to ensure Python compatibility.
# Data manipulations
import pandas as pd
import numpy as np
import utils
import joblib
# Data visualizations
import matplotlib.pyplot as plt

# %matplotlib inline
plt.style.use('seaborn-darkgrid')
import seaborn as sns
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import plotly.offline as pyo
import plotly.io as pio

# Data pre-processing
import missingno as msno
from sklearn.preprocessing import LabelEncoder
from sklearn.impute import SimpleImputer

# Date handller
import time
from datetime import datetime, timedelta, date

# For serialization and warning purpose
import pickle
import warnings

warnings.filterwarnings('ignore')
pio.renderers.default = 'notebook'  # charts export to HTML
# pd.set_option('display.height', 500)
# pd.set_option('display.max_rows', 500)
# pd.reset_option('display.max_rows')  OR pd.reset_option('all')

df = pd.read_csv("D:\Prutha\Sample\pythonProject\hotel_price_prediction\price_prediction\df.csv")

df

df.drop('Unnamed: 0', axis=1, inplace=True)

df = df[df['Year'] == 2022]

df

df.sort_values('Month', inplace=True, ignore_index=True)

ex = df.copy(deep=True)

ex

dates = []
for y, m, d in zip(ex['Year'], ex['Month'], ex['Days']):
    date = str(y) + '-' + str(m) + '-' + str(d)
    dates.append(date)
print(len(date))

ex['Dates'] = dates
ex["Dates"] = pd.to_datetime(dates)

import calendar

calendar.setfirstweekday(6)


def get_week_of_month(year, month, day):
    x = np.array(calendar.monthcalendar(year, month))
    week_of_month = np.where(x == day)[0][0] + 1
    return week_of_month


weeks = []
for y, m, d in zip(ex['Year'], ex['Month'], ex['Days']):
    week = get_week_of_month(y, m, d)
    weeks.append(week)

ex["week_number"] = weeks

ex

ex.drop(['Dates', 'Year', 'IsHoliday', 'IsWeekend'], axis=1, inplace=True)

df1 = ex[
    ['Month', 'Days', 'week_number', 'DayOfWeek', 'RateCode', 'Nights', 'Type', 'TrackCode', 'Occupied', 'ADR', 'Rate']]

df1


def outlierRemoval(data, val1):
    percentile25 = data[val1].quantile(0.25)
    percentile75 = data[val1].quantile(0.75)
    iqr_range = percentile75 - percentile25
    upper_limit = round((percentile75 + 1.5 * iqr_range), 2)
    lower_limit = round((percentile25 - 1.5 * iqr_range), 2)

    print('Min value :{}\nMax value :{}'.format(lower_limit, upper_limit))

    data_e1 = data[(data[val1] < upper_limit) & (data[val1] > lower_limit)]

    plt.figure(figsize=(16, 8))
    plt.subplot(2, 2, 1)
    sns.distplot(data[val1])
    plt.subplot(2, 2, 2)
    sns.boxplot(data[val1])
    plt.subplot(2, 2, 3)
    sns.distplot(data_e1[val1])
    plt.subplot(2, 2, 4)
    sns.boxplot(data_e1[val1])
    plt.show()

    return data_e1


data1 = outlierRemoval(df1, 'Rate')

# ML algotithm
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LinearRegression
from xgboost import XGBRegressor
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor

# Evaluation matrics
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.utils import shuffle

from sklearn.preprocessing import StandardScaler

X = data1.drop(columns=["Rate"], axis=1)
y = data1["Rate"]

# Slpiting into training set and testing set
X_train, X_test, y_train, y_test = train_test_split(X.values, y.values, test_size=0.30, random_state=15)
print('\nX_train size :{} \nX_test size  :{} \ny_train size :{} \ny_test size  :{}'.format(len(X_train),
                                                                                           len(X_test), len(y_train),
                                                                                           len(y_test)))

from sklearn.model_selection import GridSearchCV, RandomizedSearchCV
from pprint import pprint

# Function for ML computations

cv = 5  # CV value
algo = []  # algorithm name
r_2 = []  # R2 score (test)
CV = []  # CV scores mean
mae_value = []  # mae score
mse_value = []  # mse score
rmse_val = []  # rmse score
r2 = []  # R2 scorw (train)


# Main function for models
def model(algorithm, x_train_, y_train_, x_test_, y_test_, X, y):
    # start_time = timer(None)
    algorithm.fit(x_train_, y_train_)

    predicts = algorithm.predict(x_test_)
    # prediction = pd.DataFrame(predicts, columns=['Prediction'])

    kd = pd.DataFrame({'Actual': y_test_, 'Prediction': predicts})
    kd['Diff'] = round((kd.Actual - kd.Prediction), 2)

    R2 = algorithm.score(x_train_, y_train_)
    R_2 = r2_score(y_test_, predicts)

    cross_val = cross_val_score(algorithm, X, y, cv=cv)

    mae = mean_absolute_error(y_test_, predicts)
    mse = mean_squared_error(y_test_, predicts)
    rmse = np.sqrt(mean_squared_error(y_test_, predicts))

    # Appending results to Lists
    algo.append(algorithm)
    r2.append(R2)
    CV.append(cross_val.mean())
    r_2.append(R_2)
    mae_value.append(mae)
    mse_value.append(mse)
    rmse_val.append(rmse)

    # Printing results  
    print('ML Algorithm     :', algorithm)
    print("R2 Score (train) :", R2)
    print("R2 Score (test)  :", R_2)
    print("CV Scores        :", cross_val)
    print("CV Scores mean   :", cross_val.mean())
    print("MAE rate         :", mae)
    print("MSE rate         :", mse)
    print("RMSE rate        :", rmse)

    # Plot for prediction vs originals
    # sns.scatterplot(x=y_test_, y=predicts)
    # plt.xlabel('y_test')
    # plt.ylabel('Predicted')
    # plt.show()

    # timer(start_time)
    return algorithm, kd


# Commented out IPython magic to ensure Python compatibility.
# %%time
xg = XGBRegressor()
model_xg, df_xg = model(xg, X_train, y_train, X_test, y_test, X, y)

# Model save
pickle.dump(xg, open('modelXGB84.pkl', 'wb'))
loaded_model_base = pickle.load(open('modelXGB84.pkl', 'rb'))

# Month = 3
# Days = 15
# Los = 1
# Type = 3
# RateCode = 2
# TrackCode = 0
# Occupied = 88
# Adr = 94.80
# 
# n = [[Month, Days, Los, Type, RateCode, TrackCode, Occupied, Adr]]
# print(xg.predict(n))
